{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome Viet's Note Golang","text":""},{"location":"Basic/0.%20hello_world/","title":"hello world","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    fmt.Println(123)\n    fmt.Println(123.777); fmt.Println(true) // have `;` when write on one line\n    fmt.Println(\"Hello World\")\n    fmt.Println()\n\n    fmt.Println(\"Hello \" + \"World\" + \" 111\")\n    fmt.Println(\"Hello World 222\", \"Hello World \\t\\t 333\")\n    fmt.Println(\n        \"Hello World 444\",\n        \"Hello World 555\",\n    )\n    fmt.Println()\n\n    // Print a character\n    fmt.Println('A')            // print 65\n    fmt.Println(string('A'))    // print 'A'\n\n    var char1 byte = 'B'\n    fmt.Println(char1)         // print 66\n    fmt.Printf(\"%c \\n\", char1) // print 'B'\n    fmt.Println(string(char1)) // print 'B'\n\n    var char2 rune = 'C'\n    fmt.Println(char2)         // print 67\n    fmt.Printf(\"%c \\n\", char2) // print 'C'\n    fmt.Println(string(char2)) // print 'C'\n}\n</code></pre>"},{"location":"Basic/1.%20data_types/","title":"data types","text":"<pre><code>package main\n\nimport \"fmt\"\n\nfunc main() {\n\n    // unsigned integer\n    var a uint8 = 255\n    var b uint16 = 65535\n    var c uint32 = 4_294_967_295\n    var d uint64 = 18_446_744_073_709_551_615\n    fmt.Println(a, b, c, d)\n\n    // signed interger\n    var x int8 = -128\n    var y int16 = -32768\n    var z int32 = -2_147_483_648\n    var t int64 = -9_223_372_036_854_775_808\n    fmt.Println(x, y, z, t)\n\n    // floating point numbers\n    var f1 float32 = 123.456\n    var f2 float64 = 789.123456\n    fmt.Println(f1, f2)\n\n    // similar to int in C++\n    // the size of int and uint depend on system (32/64 bit)\n    var si int = -223344\n    var ui uint = 223344\n    fmt.Println(si, ui)\n\n    // character\n    var char1 byte = 'A'      // alias uint8\n    var char2 rune = '\\u2600' // alias int32, represent for Unicode character\n    fmt.Println(char1, char2)\n    fmt.Printf(\"%c \\t %c \\n\", char1, char2)\n    fmt.Printf(\"%c \\t %c \\n\", a, c)\n\n    // boolean\n    var foo bool = true\n    fmt.Println(foo)\n\n}\n</code></pre>"},{"location":"Basic/11.0%20function/","title":"function","text":"<pre><code>package main\n\nimport \"fmt\"\n\n//* 1. Declare function\nfunc sayHi() {\n    fmt.Println(\"Hiiiii\")\n}\n\n//* 2. Function with param and return value\nfunc add(a int, b int) int {\n    return a + b\n}\n\n//* also can write:\n// func add(a, b int) int {\n//  return a + b\n// }\n\n//* 3. Named return value\nfunc multiply(a int, b int) (result int) {\n    result = a * b\n    return\n}\n\n//* 4. Multiple return value\nfunc divide(a, b float32) (res float32, ok bool) {\n    if b == 0 {\n        return 0, false\n    }\n    return a / b, true\n    //* also can write:\n    // res = a / b\n    // ok = true\n    // return\n}\n\n//* 5. Variadic function\nfunc sum(args ...int) (total int) {\n    for _, value := range args {\n        // fmt.Printf(\"idx=%d, value=%d \\n \", index, value)\n        total += value\n    }\n    return\n}\n\n//* 8. Higher-Order functions\nfunc sort(arr []int, comparator func(int, int) bool) {\n    for i := 0; i &lt; len(arr)-1; i++ {\n        for j := i + 1; j &lt; len(arr); j++ {\n            if comparator(arr[j], arr[i]) {\n                arr[i], arr[j] = arr[j], arr[i] // swap\n            }\n        }\n    }\n}\n\n//* 9. Struct's methods) - function  with value/pointer receiver\ntype Car struct {\n    Model string\n    Color int\n}\n// pointer receiver: use when you need to modify data or avoid copying large structs.\nfunc (car *Car) updateCarInfoWithPointerRecevier(model string, color int) {\n    fmt.Printf(\"Pointer Receiver - Memory Address in update: %p\\n\", car)\n    car.Model = model\n    car.Color = color\n}\nfunc (car *Car) printCarInfoWithPointerRecevier() {\n    fmt.Printf(\"Pointer Receiver - Memory Address in print: %p\\n\", car)\n    fmt.Printf(\"Car's info:\\t Model= %s, Color= %x \\n\", car.Model, car.Color)\n}\n// value receiver: it makes a copy of the instance. \n// use when you don't need to modify data and the struct is small\nfunc (car Car) updateCarInfoWithValueReceiver(model string, color int) {\n    fmt.Printf(\"Value Receiver - Memory Address in update: %p\\n\", &amp;car)\n    car.Model = model\n    car.Color = color\n}\nfunc (car Car) printCarInfoWithValueReceiver() {\n    fmt.Printf(\"Value Receiver - Memory Address in print: %p\\n\", &amp;car)\n    fmt.Printf(\"Car's info:\\t Model= %s, Color= %x \\n\", car.Model, car.Color)\n}\n\n//! 10. Go doesn't support \"Default Parameter Values\" like C++, Javascript, Python, ...\n// func increase(count int, step int = 1) {} // it is impossible to write like this\n\n//! 11. Go doesn't support \"Annotation\" like Java, C#, ...\n\n//! 12. Go doesn't support \"Function Overloading\"\n// func sayHi(greet string) { // cause compile error; even when using difference parameters, return values.\n//  fmt.Println(greet)\n// }\n\nfunc main() {\n\n    // test for 1,2,3,4,5\n    sayHi()\n    fmt.Printf(\"Add func: %d \\n\", add(10, 15))\n    fmt.Printf(\"Mul func: %d \\n\", multiply(10, 15))\n    result, ok := divide(6, 3)\n    fmt.Printf(\"Div func: %f %t \\n\", result, ok)\n    fmt.Printf(\"Sum func: %v \\n\", sum(2, 4, 8, 10, 11))\n\n    // 6.1 Anonymous/lambda function\n    func() {\n        fmt.Println(\"Hello from an anonymous function\")\n    }()\n\n    // 6.2 Closures\n    count := 0\n    increment := func() int {\n        count++\n        return count\n    }\n    fmt.Printf(\"increment: %v\\n\", increment())\n    fmt.Printf(\"increment: %v\\n\", increment())\n    fmt.Printf(\"increment: %v\\n\", increment())\n    fmt.Printf(\"increment: %v\\n\", increment())\n    fmt.Printf(\"increment: %v\\n\", increment())\n\n    // 7. Function types\n    // (In C++, it's similar to the function pointer)\n    var integerComparator func(int, int) bool\n    greatComparator := func(a int, b int) bool {\n        return a &gt; b\n    }\n    lessComparator := func(a int, b int) bool {\n        return a &lt; b\n    }\n    equalComparator := func(a int, b int) bool {\n        return a == b\n    }\n\n    integerComparator = greatComparator\n    fmt.Printf(\"Type of integerComparator: %T \\t result=%t\\n\", integerComparator, integerComparator(10, 9))\n    integerComparator = lessComparator\n    fmt.Printf(\"Type of integerComparator: %T \\t result=%t\\n\", integerComparator, integerComparator(10, 9))\n    integerComparator = equalComparator\n    fmt.Printf(\"Type of integerComparator: %T \\t result=%t\\n\", integerComparator, integerComparator(10, 10))\n\n    // 8. test for higher-order functions\n    // (In C++, it's similar to passing the function pointer as a parameter)\n    arr := []int{8, 6, 4, 3, 1, 0, 9, 5, 2, 7}\n    sort(arr, greatComparator) // decrement\n    fmt.Println(arr)\n    sort(arr, lessComparator) // increment\n    fmt.Println(arr)\n\n    // 9. test for struct's method\n    myCar := Car{\"Audi\", 123}\n    fmt.Printf(\"\\nMain - Memory Address of myCar: %p \\n\\n\", &amp;myCar)\n    myCar.updateCarInfoWithValueReceiver(\"Honda\", 456)\n    myCar.printCarInfoWithValueReceiver()\n\n    fmt.Println()\n    myCar.updateCarInfoWithPointerRecevier(\"Honda\", 456)\n    myCar.printCarInfoWithPointerRecevier()\n\n}\n</code></pre>"},{"location":"Basic/11.1%20pass_params/","title":"pass params","text":"<pre><code>package main\n\nimport \"fmt\"\n\n//! pass params as values vs pass params as references\n\n// I. Basic type: int, float32, string, bool ... =&gt; pass by value\nfunc Increase(count int) int {\n    count++\n    return count\n}\n\n// II. Composite type: array, slice, map, struct\n// slice, map =&gt; pass by ref\n// array, struct =&gt; pass by value\nfunc UpdateArray(arr [3]int) {\n    arr[0] *= 10\n    arr[1] *= 10\n    arr[2] *= 10\n}\n\nfunc UpdateSlice(slice []int) {\n    for i := 0; i &lt; len(slice); i++ {\n        slice[i] *= 10\n    }\n}\n\nfunc UpdateMap(dict map[int]string) {\n    for key, _ := range dict {\n        dict[key] = \"ABC\"\n    }\n}\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc UpdatePerson(p Person) {\n    p.Name = \"Bob\"\n    p.Age = 20\n}\n\n// III. Special type: pointer, interface, variadic params, empty interface\n// i) pointer:\nfunc IncreaseWithPointer(count *int) int {\n    *count++\n    return *count\n}\nfunc UpdateArrayWithPointer(arr *[3]int) {\n    arr[0] *= 10\n    arr[1] *= 10\n    arr[2] *= 10\n}\nfunc UpdatePersonWithPointer(p *Person) {\n    p.Name = \"Bob\"\n    p.Age = 20\n}\n\n// ii) interface: ------------------------------------------------------------------------------------------------\ntype IAccount interface {\n    UpdateAccountDetails(name string, balance float64)\n    PrintAccountDetails()\n}\n\ntype Account struct {\n    Name    string\n    Balance float64\n}\n\ntype SavingsAccount struct {\n    Account      // Embedded type Account\n    InterestRate float64\n}\n\ntype CheckingAccount struct {\n    Account        // Embedded type Account\n    OverdraftLimit float64\n}\n\ntype BusinessAccount struct {\n    Account     // Embedded type Account\n    CompanyName string\n}\n\nfunc (a Account) UpdateAccountDetails(name string, balance float64) {\n    a.Name = name\n    a.Balance = balance\n}\n\nfunc (a *Account) PrintAccountDetails() {\n    fmt.Printf(\"Account Holder: %s, Balance: %.2f\\n\", a.Name, a.Balance)\n}\n\nfunc (sa *SavingsAccount) PrintAccountDetails() {\n    fmt.Printf(\"Savings Account Holder: %s, Balance: %.2f, Interest Rate: %.2f%%\\n\", sa.Name, sa.Balance, sa.InterestRate)\n}\n\nfunc (ca *CheckingAccount) PrintAccountDetails() {\n    fmt.Printf(\"Checking Account Holder: %s, Balance: %.2f, Overdraft Limit: %.2f\\n\", ca.Name, ca.Balance, ca.OverdraftLimit)\n}\n\nfunc (ba *BusinessAccount) PrintAccountDetails() {\n    fmt.Printf(\"Business Account Holder: %s, Balance: %.2f, Company: %s\\n\", ba.Name, ba.Balance, ba.CompanyName)\n}\n\nfunc updateAccountDetails(account IAccount, name string, amount float64) {\n    account.UpdateAccountDetails(name, amount)\n}\n// ------------------------------------------------------------------------------------------------\n\n// iii) empty interface:\nfunc modify(any interface{}) { \n    switch v := any.(type) {\n    case *int:\n        *v *= 2\n    }\n}\n\n// iv) variadic params:\nfunc mySum(nums ...int) int {\n    total := 0\n    for idx, num := range nums {\n        nums[idx] *= 2\n        total += num\n    }\n    return total\n}\n\nfunc main() {\n\n    // 1. pass by value\n    a := 1\n    Increase(a)\n    fmt.Printf(\"a = %d \\n\", a)\n\n    arr := [3]int{1, 2, 3}\n    UpdateArray(arr)\n    fmt.Printf(\"UpdateArray: %v \\n\", arr)\n\n    person := Person{Name: \"Viet\", Age: 25}\n    UpdatePerson(person)\n    fmt.Printf(\"UpdatePerson: %v \\n\", person)\n\n    // 2. pass by reference (under the hood, it use pointer internal)\n    slice := []int{1, 2, 3}\n    UpdateSlice(slice)\n    fmt.Printf(\"UpdateSlice: %v \\n\", slice)\n\n    myMap := map[int]string{\n        1: \"QWE\",\n        2: \"XYZ\",\n        3: \"UIO\",\n    }\n    UpdateMap(myMap)\n    fmt.Printf(\"UpdateMap: %v \\n\", myMap)\n\n    // 3. pass by reference (using pointer directly)\n    count := 99\n    IncreaseWithPointer(&amp;count) // Wow, similar to C++ (-_-)\n    fmt.Printf(\"count = %d \\n\", count)\n\n    UpdateArrayWithPointer(&amp;arr)\n    fmt.Printf(\"UpdateArrayWithPointer: %v \\n\", arr)\n\n    UpdatePersonWithPointer(&amp;person)\n    fmt.Printf(\"UpdatePersonWithPointer: %v \\n\", person)\n\n    // 4. pass a interface (behavior-like pass by reference)\n    // the way to achieve polymorphism in Go\n    var account IAccount\n    account = &amp;SavingsAccount{Account: Account{Name: \"Alice\", Balance: 1000.0}, InterestRate: 2.5}\n    account.PrintAccountDetails()\n    updateAccountDetails(account, \"Viet111\", 11111)\n    account.PrintAccountDetails() //? can you guest the output?\n\n    account = &amp;CheckingAccount{Account: Account{Name: \"Bob\", Balance: 500.0}, OverdraftLimit: 100.0}\n    account.PrintAccountDetails()\n    updateAccountDetails(account, \"Viet222\", 22222)\n    account.PrintAccountDetails() //? can you guest the output?\n\n    account = &amp;BusinessAccount{Account: Account{Name: \"Charlie\", Balance: 10000.0}, CompanyName: \"Charlie's Chocolates\"}\n    account.PrintAccountDetails()\n    updateAccountDetails(account, \"Viet111\", 33333)\n    account.PrintAccountDetails() //? can you guest the output?\n\n    x := 100\n    modify(&amp;x)\n    fmt.Printf(\"x after modify: %d \\n\", x) //? can you guest the output?\n\n    // 5. pass variadic params\n    x1 := 1\n    x2 := 2\n    x3 := 3\n    fmt.Printf(\"mySum = %d \\n\", mySum(x1, x2, x3))\n    fmt.Printf(\"x1, x2, x3 = %d %d %d \\n\", x1, x2, x3) //?  can you guest the output?\n\n}\n</code></pre>"},{"location":"Basic/11.2%20return%20_values/","title":"return values","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// 1. Single Return Value: Any basic type, composite type, or custom type\nfunc Subtract(a, b int) int {\n    return a - b\n}\n\n// 2. Multiple Return Values: useful for returning results along with errors\nfunc Divide(a, b float64) (float64, error) {\n    if b == 0 {\n        return 0, fmt.Errorf(\"division by zero\")\n    }\n    return a / b, nil\n}\n\n// 3. Named Return Values:\nfunc Multiply(a, b int) (result int) {\n    result = a * b\n    return\n}\n\n// 4. Composite Types: Slices, maps, structs, arrays, and even other functions\nfunc SliceReturning() []int {\n    return []int{1, 2, 3}\n}\n\nfunc FunctionTypeReturning() func(int, int) bool {\n    greater := func(a, b int) bool {\n        return a &gt; b\n    }\n    return greater\n}\n\n// 5. Empty Return:\nfunc Greeting() {\n    fmt.Println(\"Hello\")\n}\n\n// 6. Interface Types:\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    return 3.14 * c.Radius * c.Radius\n}\n\nfunc (c Circle) Perimeter() float64 {\n    return 2 * 3.14 * c.Radius\n}\n\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    return r.Width * r.Height\n}\n\nfunc (r Rectangle) Perimeter() float64 {\n    return 2 * (r.Width + r.Height)\n}\n\n// Function to get a Shape\nfunc GetShape(shapeType string) (Shape, error) {\n    switch shapeType {\n    case \"circle\":\n        return Circle{Radius: 5}, nil\n    case \"rectangle\":\n        return Rectangle{Width: 4, Height: 3}, nil\n    default:\n        return nil, fmt.Errorf(\"unknown shape type: %s\", shapeType)\n    }\n}\n\n// 7. Pointer:\nfunc PointerReturning() *int {\n    a := 3\n    return &amp;a\n} // when out of scope, `a` is not destructed like C++\n\nfunc main() {\n\n    // Test Subtract\n    fmt.Println(\"Subtract 10 - 3:\", Subtract(10, 3))\n\n    // Test Divide\n    if result, err := Divide(10, 2); err != nil {\n        fmt.Println(\"Divide error:\", err)\n    } else {\n        fmt.Println(\"Divide 10 / 2:\", result)\n    }\n\n    // Test Multiply\n    fmt.Println(\"Multiply 4 * 3:\", Multiply(4, 3))\n\n    // Test SliceReturning\n    fmt.Println(\"SliceReturning:\", SliceReturning())\n\n    // Test FunctionTypeReturning\n    greaterFunc := FunctionTypeReturning()\n    fmt.Println(\"Greater function result for 5 and 3:\", greaterFunc(5, 3))\n\n    // Test Greeting\n    Greeting()\n\n    // Test interface type\n    shape1, err1 := GetShape(\"circle\")\n    shape2, err2 := GetShape(\"rectangle\")\n    if err1 == nil {\n        fmt.Printf(\"Shape1 Area: %f, Perimeter: %f\\n\", shape1.Area(), shape1.Perimeter())\n    }\n    if err2 == nil {\n        fmt.Printf(\"Shape2 Area: %f, Perimeter: %f\\n\", shape2.Area(), shape2.Perimeter())\n    }\n\n    // Test PointerReturning\n    ptr := PointerReturning()\n    fmt.Println(\"Pointer value:\", *ptr)\n}\n</code></pre>"},{"location":"Basic/12.%20generic/","title":"generic","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/exp/constraints\"\n)\n\n// Golang support generic from verison 1.8\n// Generics in Go, like in many other statically typed languages, are implemented at compile time\n\n// generic with function\nfunc PrintList[T any](list []T) {\n    for _, v := range list {\n        fmt.Printf(\"%v \", v)\n    }\n}\n\nfunc Swap[T any](x, y T) (T, T) {\n    return y, x\n}\n\n// generic with struct\ntype Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(value T) {\n    s.items = append(s.items, value)\n}\n\nfunc (s *Stack[T]) Pop() T {\n    if len(s.items) == 0 {\n        var zero T\n        return zero\n    }\n\n    result := s.items[len(s.items)-1]\n    s.items = s.items[:len(s.items)-1]\n    return result\n}\n\n// constraints: any, comparable (only have == and != comparison), (find more constraint in golang.org/x/exp/constraints )\nfunc Equal[T comparable](a, b T) bool {\n    return a == b\n}\n\nfunc Max[T constraints.Ordered](a, b T) T {\n    if a &gt; b {\n        return a\n    }\n    return b\n}\n\n// customize constraint:\ntype Numbers interface {\n    ~float32 | ~float64 | ~int8 | ~uint8 | ~int16 | ~uint16 |\n        ~int32 | ~uint32 | ~int64 | ~uint64 | ~int | ~uint\n}\n\nfunc doSomethingWithNumber[T Numbers](num T) {\n    fmt.Printf(\"doSomethingWithNumber %v \\n\", num)\n}\nfunc doSomethingWithFloat[T float32 | float64](num T) { // directly use contraint \n    fmt.Printf(\"doSomethingWithFloat %v \\n\", num)\n}\n\ntype Flyable interface {\n    Fly()\n}\n\ntype Plane struct{}\n\ntype Bird struct{}\n\nfunc (p Plane) Fly() {\n    fmt.Println(\"The plane is flying\")\n}\n\nfunc (b Bird) Fly() {\n    fmt.Println(\"The bird is flying\")\n}\n\n// generic function that accepts any type implementing Flyable\nfunc FlyAll[T Flyable](flyables []T) {\n    for _, value := range flyables {\n        value.Fly()\n    }\n}\n\n// More complex example wih generic\nfunc Map[T, U any](list []T, myFunc func(T) U) []U {\n    var result = make([]U, len(list))\n    for idx, v := range list {\n        result[idx] = myFunc(v)\n    }\n    return result\n}\n\nfunc main() {\n    // Lets try with other data-type that you think it invalid\n\n    PrintList([]float64{1.1, 2.2, 3.3})\n    fmt.Println()\n\n    PrintList([]string{\"A\", \"BB\", \"CCC\"})\n    fmt.Println()\n\n    var myStack Stack[int]\n    myStack.Push(12)\n    myStack.Push(23)\n    myStack.Push(34)\n    fmt.Println(myStack)\n    myStack.Pop()\n    fmt.Println(myStack)\n\n    // doSomethingWithNumber(\"AAA\") // cause compile error\n    doSomethingWithNumber(1000000)\n    doSomethingWithFloat(12.3333)\n\n    fmt.Printf(\"Max: %v \\n\", Max(1, 2))\n\n    FlyAll([]Flyable{\n        Plane{},\n        Plane{},\n        Bird{},\n        Bird{},\n        Bird{},\n    })\n\n    duplicateNumber := func(a int32) int64 { return int64(a * 2) }\n    list := []int32{3, 4, 5, 6, 7, 8, 9, 10}\n    result := Map(list, duplicateNumber)\n    // result := Map(list, func(x int32) int64 { return int64(x * 2) }) // aslo can directly pass lambda func\n    for _, val := range result {\n        fmt.Printf(\"%v \", val)\n    }\n}\n</code></pre>"},{"location":"Basic/13.%20pointer_and_nil/","title":"pointer and nil","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"unsafe\"\n)\n\n//* Go has pointers, similar to C/C++, but with some key differences:\n\n// 1. Pointer Arithmetic\n// Go doesn't support pointer arithmetic. Operations like ptr++ or ptr += 5 are invalid.\n\n// 2. Dereference Behavior\n// Dereferencing a nil pointer in Go causes a runtime panic.\n// In C++, dereferencing a null pointer results in undefined behavior.\n\n// 3. Memory Management\n// Go has a garbage collector (GC) for heap allocations. Stack-allocated variables\n// are automatically deallocated when they go out of scope.\n\n// 4. Initialization\n// Pointers can be initialized using the `new` keyword or by taking the address of a variable.\n\n// 5. Nil Pointers\n// Uninitialized pointers in Go have a value of nil. Dereferencing a nil pointer causes a runtime panic.\n\n// 6. Struct Field Access\n// Go allows direct access to struct fields through a pointer without explicit dereferencing.\n\ntype Person struct {\n    Name string\n    Age  int\n}\n\nfunc main() {\n    // 1. Declaration\n    var p1 *int\n    var p2 *Person\n\n    // 2. Initialization\n    i := 100\n    p1 = &amp;i\n    p2 = &amp;Person{}\n    fmt.Printf(\"Address of i = %p\\n\", &amp;i)\n    fmt.Printf(\"Value of p1 = %p\\n\", p1)\n\n    // 3. Nil pointer\n    var p3 *int\n    if p3 == nil {\n        fmt.Println(\"p3 is a nil pointer\")\n    }\n\n    // 4. Dereferencing pointer\n    fmt.Printf(\"p1 = %p; *p1 = %d \\n\", p1, *p1)\n    *p1 = 200\n    fmt.Printf(\"p1 = %p; *p1 = %d \\n\", p1, *p1)\n\n    // 5. Struct field access\n    fmt.Printf(\"p2 = %p; *p2 = %v \\n\", p2, *p2)\n    p2.Name = \"Alice\" // Direct access, equivalent to (*p2).Name = \"Alice\"\n    p2.Age = 17\n    fmt.Printf(\"p2 = %p; *p2 = %v \\n\", p2, *p2)\n\n    // 6. `new` Keyword\n    p1 = new(int)\n    p2 = new(Person) // equivalent to p2 = &amp;Person{}\n\n    // 7. Pointer and function\n    // Pointers can be parameters and return values\n    // func modifyValue(p *int) { *p = 10 }\n    // func getPerson() *Person { return &amp;Person{Name: \"Bob\", Age: 30} }\n\n    // 8. Pointer to pointer\n    var p4 **int\n    p4 = &amp;p1\n    fmt.Printf(\"p4 = %p; *p4 = %p; **p4 = %d \\n\", p4, *p4, **p4)\n\n    // 9. Slices and maps\n    // Slices and maps are reference types, effectively passed by reference without explicit pointers\n    slice := []int{1, 2, 3}\n    modifySlice(slice)\n    fmt.Println(slice) // Output: [100 2 3]\n\n    // 10. Unsafe pointers\n    // The unsafe package allows C-style pointer arithmetic and type conversions\n\n    // pointer arithmetic:\n    arr := [5]int{10, 20, 30, 40, 50}\n    ptr := unsafe.Pointer(&amp;arr[0])\n    size := unsafe.Sizeof(arr[0])\n    for i := 0; i &lt; len(arr); i++ {\n        // Convert the pointer back to an integer pointer and dereference it\n        elemPtr := (*int)(unsafe.Pointer(uintptr(ptr) + uintptr(i)*size))\n        fmt.Printf(\"Element %d: %d\\n\", i, *elemPtr)\n    }\n\n    // type conversions:\n    var f float32 = 5.7788\n    // var ptr2 *int32 = (*int32)(&amp;f) // cause compile err\n    var unsafePtr unsafe.Pointer = unsafe.Pointer(&amp;f) // must use unsafe pointer for convert difference pointer type\n    var ptr2 *int32 = (*int32)(unsafePtr)\n    fmt.Printf(\"%v \\n\", unsafePtr)\n    fmt.Printf(\"%v \\n\", ptr2)\n    fmt.Printf(\"%p \\n\", &amp;f)\n\n    // 11. No pointer-to-array types\n    // Go uses slices where C/C++ might use pointer-to-array\n\n    // 12. Escape analysis\n    // Go's compiler can sometimes allocate variables on the stack even when returned as pointers\n    p5 := getPointer()\n    fmt.Println(*p5)\n}\n\nfunc modifySlice(s []int) {\n    s[0] = 100\n}\n\nfunc getPointer() *int {\n    x := 42\n    return &amp;x // May be allocated on stack or heap, determined by escape analysis\n}\n\n// 13. Interface values\n// Interface values contain both type and value components, which can lead to reference-like behavior\n// var x interface{} = &amp;MyStruct{}\n\n// Note: Zero Value Initialization\n// Variables (including pointers) are initialized to their zero value if not explicitly initialized.\n// For pointers, the zero value is nil.\n</code></pre>"},{"location":"Basic/14.%20misc/","title":"14. misc","text":"<pre><code>// type alias\n// literal\n// reflect\n// unsafe\n// nil\npackage main\n\n// type alias\ntype MyInt = int\n\n// type custom\ntype MyCustomInt int\n\nfunc main() {\n\n}\n</code></pre>"},{"location":"Basic/2.%20variables_and_values/","title":"variables and values","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n\n    // 1. Declare with initialization and specific type\n    var a int32 = 123456\n    // var a int32 =  99 // cannot re-declare\n    // var a float32 = 12.22 // cannot re-declare, even diffence data type\n    var b, c float32 = 88.99, 44.55\n\n    fmt.Printf(\"Type of a: %T value = %d \\n\", a, a)\n    fmt.Printf(\"Type of b: %T value = %f \\n\", b, b)\n    fmt.Printf(\"Type of c: %T value = %f \\n\", c, c)\n    fmt.Println()\n\n    // 2. Declare with initialization and infered type\n    var d = 6789\n    var e, f, s = 12, 34.99, \"hello world!\"\n    g := -333\n    // g := 11 // cannot re-declare\n    {\n        g := 11 // it's oke, not change `g` outside. Similar to C++\n        fmt.Printf(\"g in local scope: %v \\n\", g)\n    }\n    h := 123.666\n    fmt.Printf(\"Type of d: %T value = %v \\n\", d, d)\n    fmt.Printf(\"Type of e: %T value = %v \\n\", e, e)\n    fmt.Printf(\"Type of f: %T value = %v \\n\", f, f)\n    fmt.Printf(\"Type of s: %T value = %v \\n\", s, s)\n    fmt.Printf(\"Type of g: %T value = %v \\n\", g, g)\n    fmt.Printf(\"Type of h: %T value = %v \\n\", h, h)\n\n    // The grouping is particularly useful when you have several related variables, such as:\n    var (\n        // `0x` is prefix of hex value literal. Check file `12. misc.go` to see more about Golang's literals\n        // underscore to seperate digits in numeric literals for improved readability (similar to those in java, c#, ts, rust, python)\n        red   = 0xFF_00_00\n        green = 0x00_FF_00\n        blue  = 0x00_00_FF\n        alpha = 255\n    )\n    // check file `12. misc.go` to see more about fmt.printf's format specifiers\n    fmt.Printf(\"red: %x ,green: %#x, blue: %06X, alpha: %#06x (%#x) \\n\", red, green, blue, alpha, alpha)\n    fmt.Println()\n\n    // 3. Delarce without initialization\n    var x int\n    var y bool\n    var z float64\n    var str string\n    fmt.Printf(\"Type of x  : %T value = %v\\n\", x, x)\n    fmt.Printf(\"Type of y  : %T value = %v\\n\", y, y)\n    fmt.Printf(\"Type of z  : %T value = %v\\n\", z, z)\n    fmt.Printf(\"Type of str: %T value = %v\\n\", str, str)\n\n}\n\n// Similar to C++, Go also have global/local/formal variable.\n// If dont init, local and global variables are initialized to their default value\n// integer, floatting point     = 0\n// bool                         = false\n// string                       = \"\"\n// pointer, func                = nil\n// slice, map, chan, interface  = nil\n</code></pre>"},{"location":"Basic/3.%20operator/","title":"operator","text":"<pre><code>func main() {\n\n    //* 1. Go doesn't support the ternary operator like C++\n    // a := x &gt; 10 ? x : 0\n\n    //* 2. Go doesn't support the prefix ++ operator\n    // ++a // doesn't work\n    // a++ // okay\n\n    //* 3. NOT vs XOR (bitwise) operator in Go\n    // In C++, ~x is used for the NOT operator, and (x ^ y) is used for the XOR operator.\n    // In Go, ^x is used for the NOT operator, and (x ^ y) is used for the XOR operator. \n    // The difference is that ^ is a unary operator for NOT and a binary operator for XOR.\n    // x := ^x       // NOT operator\n    // a := x ^ y    // XOR operator\n\n    //* 4. The remaining operators in Go are similar to those in C++\n    // Arithmetic Operators:   +    -    *    /    %    ++    --\n    // Relational Operators:   ==   !=   &gt;    &lt;    &gt;=   &lt;=\n    // Logical Operators:      &amp;&amp;   ||   !\n    // Bitwise Operators:      &amp;    |    ^    &lt;&lt;   &gt;&gt;\n    // Assignment Operators:   =    +=   -=   *=   /=   %=   &gt;&gt;=  &lt;&lt;=  &amp;=  ^=  |=\n\n}\n</code></pre>"},{"location":"Basic/4.%20constant/","title":"constant","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// The const keyword in Go is limited to basic types (like integers, floats, booleans, and strings)\n\nconst MOD = int32(1e9 + 7)\nconst PI float32 = 3.14\nconst _PI = 3.14159\n\nfunc main() {\n\n    fmt.Printf(\"Type of MOD : %-7T   value = %v \\n\", MOD, MOD)\n    fmt.Printf(\"Type of PI  : %-7T   value = %v \\n\", PI, PI)\n    fmt.Printf(\"Type of _PI : %-7T   value = %v \\n\", _PI, _PI)\n\n    const str = \"This is constant string\"\n    fmt.Printf(\"Type of str : %-7T   value = %v \\n\\n\", str, str)\n\n    const (\n        WIDTH  = 5\n        HEIGHT = 4.3\n        AREA   = WIDTH * HEIGHT\n\n        // Enumerated constants using iota\n        RED = iota\n        GREEN\n        BLUE\n\n        MY_VALUE bool = true\n    )\n\n    fmt.Printf(\"Type of WIDTH    : %-7T   value = %v \\n\", WIDTH, WIDTH)\n    fmt.Printf(\"Type of HEIGHT   : %-7T   value = %v \\n\", HEIGHT, HEIGHT)\n    fmt.Printf(\"Type of AREA     : %-7T   value = %v \\n\", AREA, AREA)\n    fmt.Printf(\"Type of RED      : %-7T   value = %v \\n\", RED, RED)\n    fmt.Printf(\"Type of GREEN    : %-7T   value = %v \\n\", GREEN, GREEN)\n    fmt.Printf(\"Type of BLUE     : %-7T   value = %v \\n\", BLUE, BLUE)\n    fmt.Printf(\"Type of MY_VALUE : %-7T   value = %v \\n\", MY_VALUE, MY_VALUE)\n\n}\n</code></pre>"},{"location":"Basic/4.%20standard_io/","title":"standard IO","text":"<pre><code>package main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc flushStdin() {\n    // need flush stdin. Similar to C/C++ stdin. \ud83d\ude11\n    reader := bufio.NewReader(os.Stdin)\n    reader.ReadString('\\n')\n}\n\nfunc PrintAndScan() {\n    var name string\n    var age uint8\n    var height float32\n\n    // Let compile to aware difference between scan(),scanln(), scanf()\n    n, err := fmt.Scan(&amp;name, &amp;age, &amp;height)\n    fmt.Printf(\"Hello %s, yo = %d, height = %f  \\n\", name, age, height)\n    fmt.Printf(\"Number param rev data: %d, err = %v \\n\\n\", n, err)\n\n    flushStdin()\n\n    name = \"\"\n    age = 0\n    height = 0\n    fmt.Scanln(&amp;name, &amp;age)\n    fmt.Printf(\"Hello %s, %d, %f \\n\\n\", name, age, height)\n\n    flushStdin()\n\n    name = \"\"\n    age = 0\n    height = 0\n    fmt.Scanf(\"%s\", &amp;name)\n    flushStdin()\n    fmt.Scanf(\"%d\", &amp;age)\n    flushStdin()\n    fmt.Scanf(\"%f\", &amp;height)\n    fmt.Printf(\"Hello %s, %d, %f \\n\\n\", name, age, height)\n\n    // scanf() on one-line\n    // fmt.Scanf(\"%s %d %f\", &amp;name, &amp;age, &amp;height)\n    // or\n    // fmt.Scanf(\"%v %v %v\", &amp;name, &amp;age, &amp;height)\n\n    // key diff:\n    // Scan() will stop when read enough data\n    // Scanln() and Scanf will stop when meet newline\n}\n\nfunc main() {\n\n    // PrintAndScan()\n    buffer := make([]byte, 1024)\n    n, err := os.Stdin.Read(buffer)\n    if err != nil {\n        fmt.Println(\"os.Stdin.Read err:\", err)\n    } else {\n        buffer[20] = 'A'\n        fmt.Println(\"buffer: \", string(buffer[:n-1]))\n\n        n, err := os.Stdout.Write(buffer)\n        fmt.Printf(\"\\n n bytes written = %d, err = %v \\n\\n\", n, err)\n    }\n}\n</code></pre>"},{"location":"Basic/5.%20control_statement/","title":"control statement","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// !!! WARN: This file comprises infinite loops.\nfunc main() {\n\n    // 1. IF-ELSE-SWITCH\n    var x = 10\n    var y = 5\n    var z = 1\n\n    if x &gt; y &amp;&amp; y &gt; z { // could write with parentheses like: if (x &gt; y &amp;&amp; y &gt; z) {}\n        fmt.Println(\"x &gt; y &amp;&amp; y &gt; z\")\n    } else if y &gt; z {\n        fmt.Println(\"x &lt;= y\")\n    } else {\n        fmt.Println(\"y &lt;= z\")\n    }\n\n    // Note: else if /else statements must be placed on the same line as\n    //       the closing curly bracket  of the preceding if or else if block\n    // if x &lt;= y {\n    //   fmt.Println(\"x &lt;= y\")\n    // }\n    // else { // This will cause a syntax error\n    // }\n\n    // use expression before condition statement\n    if y = y * 5; x &gt; y {\n\n    }\n\n    // switch-case\n    color := \"green\"\n    switch color { // could write with parentheses like: switch (color) {}\n    case \"red\":\n        fmt.Println(\"M\u00e0u \u0111\u1ecf\")\n    case \"blue\", \"green\":\n        fmt.Println(\"M\u00e0u xanh\")\n    default:\n        fmt.Println(\"\u00c9o bi\u1ebft\")\n    }\n\n    // 2. LOOP - Golang does not have `while` or `do...while` loops\n    for i := 0; i &lt; 5; i++ {\n        fmt.Print(i)\n    }\n    // for (i := 0; i &lt; 10; i++) { // compile error when wrap by parentheses\n    //  fmt.Println(i)\n    // }\n\n    var i int = 0\n    for ;i &lt; 100; { // &lt;=&gt; while (i&lt;10) in another languages\n\n    }\n\n    // otmit simicolon if have only condition statement\n    for i &lt; 100 {\n\n    }\n\n    // also possible omit another statement, such as:\n    for i := 1; ; {\n        i *= 2\n    }\n    for ; ; i += 2 {\n    }\n\n    // infinite loop\n    for { // &lt;=&gt; while (true) in another languages\n\n    }\n\n    // range loop\n    fmt.Println()\n    arr := []string{\"hello\", \"world\", \"!!!\"}\n    for idx, val := range arr {\n        fmt.Println(idx, \": \"+val)\n    }\n\n    // omit index\n    for _, val := range arr {\n        fmt.Print(val + \"\\t\")\n    }\n\n    fmt.Println()\n    // omit value\n    for idx, _ := range arr {\n        fmt.Print(arr[idx] + \" \")\n    }\n\n    // The `break` or `continue` is similar to those in C/C++\n    // It can also `break` or `continue` with a label (purpose: to break/continue at the indicated for-loop).\nLOOP_I:\n    for i := 0; i &lt; 5; i++ {\n    LOOP_J:\n        for j := 0; j &lt; 5; j++ {\n            // LOOPP_K:\n            for k := 0; k &lt; 5; k++ {\n                if i == 1 &amp;&amp; j == 1 &amp;&amp; k == 1 {\n                    fmt.Printf(\"i=%d, j=%d, k=%d continnueeeee\\n\", i, j, k)\n                    continue LOOP_J // Break out of the LOOP_J\n                }\n                if i == 2 &amp;&amp; j == 2 &amp;&amp; k == 2 {\n                    fmt.Printf(\"i=%d, j=%d, k=%d breakkkkkkkkk\\n\", i, j, k)\n                    break LOOP_I // Continue with the next iteration of the LOOP_I\n                }\n                fmt.Printf(\"i=%d, j=%d, k=%d\\n\", i, j, k)\n            }\n        }\n    }\n\n    // The `goto` operator is like C/C++\n    goto EXIT\n    fmt.Println(\"Done 1111\")\n\nEXIT:\n    fmt.Println(\"Done 2222\")\n\n}\n</code></pre>"},{"location":"Basic/6.0%20array/","title":"array","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// array in Go is similar to static array in C++\n// array type = size + datatype, so:  [5]int != [4]int\n\nfunc main() {\n\n    fmt.Println(\"------------- One-dimensional array -----------------------\")\n    // Declare an array\n    var a [3]int\n    fmt.Println(\"a = \", a)\n\n    // Declare and fully initialize array elements\n    var b = [3]byte{71, 85, 90}\n    var c [2]rune = [2]rune{'\\u1007', '\\u1997'} // verbose but unnecessarily\n    fmt.Println(\"b = \", b)\n    fmt.Println(\"c = \", c)\n\n    // Declare and initialize without setting values to array elements\n    var arr1 = [3]int{}\n    var arr2 = [0]int{}\n    fmt.Println(\"arr1 = \", arr1, \"\\tlen = \", len(arr1))\n    fmt.Println(\"arr2 = \", arr2, \"\\t\\tlen = \", len(arr2))\n\n    // Shorthand for declaring and initializing (partially and fully)\n    d := [4]float32{1.1, 2.2} // d[2], d[3] will be filled with default values of type\n    e := [2]string{\"Hello\", \"Go\"}\n\n    // Without length declaration. Compiler will infer the length of the array\n    var f = [...]bool{true, false, false, false, true, true}\n    g := [...]bool{true, true}\n    h := [...]int{}\n\n    fmt.Println()\n    fmt.Printf(\"Type of a: %-12T  len = %d  value = %v, %v, %v     \\n\", a, len(a), a[0], a[1], a[2])\n    fmt.Printf(\"Type of b: %-12T  len = %d  value = %v, %v, %v     \\n\", b, len(b), b[0], b[1], b[2])\n    fmt.Printf(\"Type of c: %-12T  len = %d  value = %c, %c         \\n\", c, len(c), c[0], c[1])\n    fmt.Printf(\"Type of d: %-12T  len = %d  value = %v, %v, %v, %v \\n\", d, len(d), d[0], d[1], d[2], d[3])\n    fmt.Printf(\"Type of e: %-12T  len = %d  value = %v, %v         \\n\", e, len(e), e[0], e[1])\n    fmt.Printf(\"Type of f: %-12T  len = %d  value = %v, %v         \\n\", f, len(f), f[0], f[1])\n    fmt.Printf(\"Type of g: %-12T  len = %d  value = %v, %v         \\n\", g, len(g), g[0], g[1])\n    fmt.Printf(\"Type of h: %-12T  len = %d                         \\n\", h, len(h))\n\n    // Accessing and modifing array elements\n    a[0] = 7777\n    a[2] = 9999999\n    fmt.Printf(\"Type of a: %-12T  len = %d  value = %v, %v, %v   \\n\\n\", a, len(a), a[0], a[1], a[2])\n\n    fmt.Println(\"------------- Multi-dimensional array -----------------------\")\n    var matrix1 = [3][3]int{}\n    fmt.Println(\"matrix1 = \", matrix1)\n\n    var matrix2 = [3][3]int{{1, 2, 3}, {4, 5}, {7, 8}}\n    fmt.Println(\"matrix2 = \", matrix2, \"\\t nRow = \", len(matrix2), \"; nColumn = \", len(matrix2[0]))\n\n    var matrix3 = [2][3]int{\n        {1, 2, 3},\n        {4, 5, 6},\n    }\n    fmt.Println(\"matrix3 = \", matrix3, \"\\t\\t nRow = \", len(matrix3), \"; nColumn = \", len(matrix3[0]))\n\n    // Accessing and modifing array elements\n    matrix3[0][1] = 222\n    matrix3[1][2] = 666\n    fmt.Println(\"matrix3 = \", matrix3)\n\n    // Shorthand\n    matrix4 := [2][2]string{{\"able\", \"bana\"}, {\"hihi\", \"hehe\"}}\n    fmt.Println(\"matrix4 = \", matrix4)\n\n    // dont use infered length for multi-dimsional array such as:\n    // matrix := [...][...]string{{\"able\", \"bana\"}, {\"hihi\", \"hehe\"}} // this is not work\n\n    fmt.Println(\"\\n ------------- Some array usages ----------------------------\")\n    // Initialize Only Specific Elements\n    x := [5]int{1: 10, 2: 40} // x[1] = 10, x[2] = 40\n    fmt.Println(\"x =\", x)\n\n    var mat = [3][4]int{\n        0: {1: 10, 2: 20},                   // row 0\n        2: {0: 100, 1: 200, 2: 300, 3: 400}, // row 2\n    }\n    fmt.Println(\"mat = \", mat)\n\n    // Copy array\n    x1 := [3]int{7, 8, 9}\n    x2 := x1\n    fmt.Println(\"x2 =\", x2)\n    x3 := [3]int{}\n    x3 = x2\n    fmt.Println(\"x3 =\", x3)\n\n    mat1 := [2][3]bool{{true, true, true}, {false, false, false}}\n    mat2 := mat1\n    fmt.Println(\"mat2 =\", mat2)\n\n    //  Declare and initialize array of anonymous structs\n    listPerson1 := [3]struct {\n        name string\n        age  int\n    }{\n        {name: \"\u00c2n\", age: 19},\n        {name: \"B\u00ecnh\", age: 25},\n        {name: \"\u0110\u1ee9c\", age: 33},\n    }\n    fmt.Println(listPerson1)\n\n    listPerson2 := [3]struct {\n        name string // end with newline or semicolon\n        age  int\n    }{\n        {name: \"An\", age: 19},\n        {name: \"Binh\", age: 25},\n        {name: \"Duc\", age: 33},\n    }\n    fmt.Println(listPerson2)\n\n}\n</code></pre>"},{"location":"Basic/6.1%20slice/","title":"slice","text":"<pre><code>package main\n\nimport \"fmt\"\n\n// Slice in Go similar dynamic array in C++\n\nfunc main() {\n\n    // Slice declare and initialize similar to array, except don't specify length\n    var a = []int{1, 2, 3}\n    b := []float32{3.1, 2.1}\n\n    fmt.Printf(\"a = %v\\t len = %d, cap = %d\\n\", a, len(a), cap(a))\n    fmt.Printf(\"b = %v\\t len = %d, cap = %d\\n\", b, len(b), cap(b))\n\n    // Create Slice using make(type, len, [cap]) function\n    c := make([]int, 3, 5)\n    fmt.Printf(\"c = %v\\t len = %d, cap = %d\\n\", b, len(c), cap(c))\n\n    // Create Slice from array\n    arr := [5]int{7, 8, 9, 10, 11}\n    d := arr[:] //  dont write `d := arr`; because `d` will be an array\n    fmt.Printf(\"d = %v\\t len = %d, cap = %d\\n\", d, len(d), cap(d))\n    d[0] *= 2\n    fmt.Printf(\"d = %v\\t len = %d, cap = %d\\n\", d, len(d), cap(d))\n    fmt.Printf(\"arr = %v\\t len = %d, cap = %d\\n\", arr, len(arr), cap(arr)) // data not change !!!\n\n    e := arr[:3] // &lt;=&gt; arr[0:3]\n    f := arr[1:] // &lt;=&gt; arr[1:len(arr)]\n    g := arr[2:4]\n    fmt.Printf(\"e = %v\\t len = %d, cap = %d\\n\", e, len(e), cap(e))\n    fmt.Printf(\"f = %v\\t len = %d, cap = %d\\n\", f, len(f), cap(f))\n    fmt.Printf(\"g = %v\\t len = %d, cap = %d\\n\", g, len(g), cap(g))\n\n    // slice2 := slice1 or slice2 := slice1[x:y] will make slice2 ref to [x:y] in slice1\n    // data in slice2 change =&gt; data in slice1 change\n    h := g\n    h[0] *= 2\n    fmt.Printf(\"h = %v\\t len = %d, cap = %d\\n\", h, len(h), cap(h))\n    fmt.Printf(\"g = %v\\t len = %d, cap = %d\\n\", g, len(g), cap(g))         // data change\n    fmt.Printf(\"arr = %v\\t len = %d, cap = %d\\n\", arr, len(arr), cap(arr)) // data change\n\n    // Slice append. New slice dont ref to old slice\n    slice1 := []int{1, 2, 3}\n    fmt.Printf(\"slice1 = %v\\t len = %d, cap = %d\\n\", slice1, len(slice1), cap(slice1))\n    slice2 := append(slice1, 4, 5, 6)\n    fmt.Printf(\"slice2 = %v\\t len = %d, cap = %d\\n\", slice2, len(slice2), cap(slice2))\n\n    // change slice2 dont make change in slice1\n    slice2[0] = 9\n    fmt.Printf(\"slice1 = %v\\t len = %d, cap = %d\\n\", slice1, len(slice1), cap(slice1))\n    fmt.Printf(\"slice2 = %v\\t len = %d, cap = %d\\n\", slice2, len(slice2), cap(slice2))\n\n    // append with variadic params\n    slice3 := append(slice1, slice2...)\n    fmt.Printf(\"slice3 = %v\\t len = %d, cap = %d\\n\", slice3, len(slice3), cap(slice3))\n\n    // Copy slice. Dest slice dont ref to source slice\n    // data in dest slice change dont affect to source slice\n    slice6 := []int{7, 8, 9}\n    {\n        var slice7 []int\n        var n = copy(slice7, slice6) // will not work because slice7 is nil\n        fmt.Println(\"n = \", n)\n        fmt.Printf(\"slice7 = %v\\t len = %d, cap = %d\\n\", slice7, len(slice7), cap(slice7))\n    }\n\n    {\n        slice8 := make([]int, 3)\n        var n = copy(slice8, slice6)\n        fmt.Println(\"n = \", n)\n        fmt.Printf(\"slice8 = %v\\t len = %d, cap = %d\\n\", slice8, len(slice8), cap(slice8))\n    }\n\n}\n</code></pre>"},{"location":"Basic/6.2%20string/","title":"string","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\n// String represents a sequence of bytes (UTF-8 encoded text)\n// String is read-only (immutable)\nfunc main() {\n\n    // 1. Declaration and initialization\n    var str1 = \"Hi Go's string1\"\n    str2 := \"Hi Go's string2\"\n    str3 := `Hi \\t\\n Go's raw string3\nhere is newline of string3`\n\n    fmt.Printf(\"%s\\n\", str1)\n    fmt.Printf(\"%s\\n\", str2)\n    fmt.Printf(\"%s\\n\", str3)\n\n    // 2. Immutability\n    str4 := \"Hello string4\"\n    // str4[0] = 'A' // this cause syntax error\n\n    // 3. Access individual byte using indexing\n    fmt.Printf(\"str4[0] = %c \\n\", str4[0])\n    fmt.Printf(\"str4[1] = %s \\n\", string(str4[1]))\n\n    // 4. Length\n    fmt.Printf(\"Length of str4(%s) = %d\\n\", str4, len(str4))\n\n    // 5. Concatenate using `+` operator\n    concatStr := str1 + \" (^.^) \" + str2\n    fmt.Printf(\"Concat string: %s. Address: %p %p %p \\n\", concatStr, &amp;concatStr, &amp;str1, &amp;str2)\n\n    // 6. String with hex value literal\n    var str5 = \"hihihi \\u0000 \\u0001 \\u0002 \\u001B \\u007F \\xe2\\x8c\\x98\"\n    fmt.Printf(\"str5: %s \\n\", str5)\n    fmt.Printf(\"str5: %q \\n\", str5)\n    fmt.Printf(\"str5: %+q\\n\", str5)\n    /* Explain: `q` flag replace unprintable characters by hex code value,\n    (https://en.wikipedia.org/wiki/Control_character)\n    with `+` flag it escapses non-ascii characters */\n\n    // 7. String and []byte\n    // Because string is immutable =&gt; not efficient if we change the string many time\n    {\n        // 7.1 type conversion: string to []byte and verse vice\n        buf := []byte(\"One Two Three\")\n        str := string(buf)\n\n        fmt.Printf(\"7.1) %s\\n\", buf)\n        fmt.Printf(\"7.1) %v %p\\n\", buf, &amp;buf)\n        fmt.Printf(\"7.1) %s %p\\n\", str, &amp;str)\n\n        // 7.2 append string \" Five\" to `buf` slice\n        buf1 := append(buf, []byte(\" Five\")...)\n        result := string(buf1)\n        fmt.Printf(\"7.2) %s\\n\", result)\n\n        // 7.3 insert substring at index 13th\n        pos := 13\n        insertStr := \" Four\"\n        buf2 := append(buf1[:pos], append([]byte(insertStr), buf1[pos:len(buf1)]...)...)\n        fmt.Printf(\"7.3) %s\\n\", buf2) // dont need convert to string when print []byte\n\n        // 7.4 remove substring at index 7th, len = 6 (it is \" Three\")\n        size := 6\n        idx := 7\n        buf3 := append(buf2[:idx], buf2[idx+size:len(buf2)]...)\n        fmt.Printf(\"7.4) %s\\n\", buf3)\n    }\n\n    // 8. String Builder\n    // (efficient to concatenating multiple strings, dynamic building strings in loop)\n    var builder strings.Builder\n    builder.WriteString(\"https\")\n    builder.WriteByte(':')\n    builder.WriteRune('/')\n    builder.WriteRune('/')\n    builder.Write([]byte(\"chatgpt.com\"))\n    fmt.Printf(\"%s\\n\", builder.String())\n\n\n    // Uncomment to learn most common strings's functions:\n    // fmt.Println(\"--------- The most common utility function for string -------------\")\n    // commonStringsFunction()\n}\n\nfunc commonStringsFunction() {\n\n    str := \"Hello, World@ Welcome to Go programming. @@\"\n\n    // 1. Contains\n    fmt.Printf(\"1. Contains: %t\\n\", strings.Contains(str, \"World\")) // true\n\n    // 2. Count\n    fmt.Printf(\"2. Count: %d\\n\", strings.Count(str, \"o\")) // 4\n\n    // 3. Fields\n    fmt.Printf(\"3. Fields: %v\\n\", strings.Fields(str)) // [\"Hello,\" \"World!\" \"Welcome\" \"to\" \"Go\" \"programming.\"]\n\n    // 4. HasPrefix\n    fmt.Printf(\"4. HasPrefix: %t\\n\", strings.HasPrefix(str, \"Hello\")) // true\n\n    // 5. HasSuffix\n    fmt.Printf(\"5. HasSuffix: %t\\n\", strings.HasSuffix(str, \"programming. @@\")) // true\n\n    // 6. Index\n    fmt.Printf(\"6. Index: %d\\n\", strings.Index(str, \"World\")) // 7\n\n    // 7. Join\n    elems := []string{\"Go\", \"is\", \"awesome\"}\n    fmt.Printf(\"7. Join: %q\\n\", strings.Join(elems, \" \")) // \"Go is awesome\"\n\n    // 8. Split\n    fmt.Printf(\"8. Split: %q\\n\", strings.Split(str, \" \")) // [\"Hello,\" \"World!\" \"Welcome\" \"to\" \"Go\" \"programming.\"]\n\n    // 9. ToLower\n    fmt.Printf(\"9. ToLower: %q\\n\", strings.ToLower(str)) // \"hello, world! welcome to go programming.\"\n\n    // 10. ToUpper\n    fmt.Printf(\"10. ToUpper: %q\\n\", strings.ToUpper(str)) // \"HELLO, WORLD! WELCOME TO GO PROGRAMMING.\"\n\n    // 11. Replace\n    fmt.Printf(\"11. Replace: %q\\n\", strings.Replace(str, \"World\", \"Gopher\", 1)) // \"Hello, Gopher! Welcome to Go programming.\"\n\n    // 12. Trim\n    fmt.Printf(\"12. Trim: %q\\n\", strings.Trim(str, \"H@\")) // \"ello, World@ Welcome to Go programming\"\n\n    // 13. TrimSpace\n    str2 := \"    \\tGo programming\\n\\t    \"\n    fmt.Printf(\"13. TrimSpace: %q\\n\", strings.TrimSpace(str2)) // \"Go programming\"\n\n    // 14. ContainsAny\n    fmt.Printf(\"14. ContainsAny: %t\\n\", strings.ContainsAny(str, \"xyz\")) // false\n\n    // 15. EqualFold\n    fmt.Printf(\"15. EqualFold: %t\\n\", strings.EqualFold(\"Go\", \"go\")) // true\n\n    // 16. Cut\n    before, after, found := strings.Cut(str, \"World\")\n    fmt.Printf(\"16. Cut: %q %q %t\\n\", before, after, found) // \"Hello, \" \" Welcome to Go programming. @@\" true\n\n    // 17. CutPrefix\n    after, found = strings.CutPrefix(str, \"Hello, \")\n    fmt.Printf(\"17. CutPrefix: %q %t\\n\", after, found) // \"World@ Welcome to Go programming. @@\" true\n\n    // 18. CutSuffix\n    before, found = strings.CutSuffix(str, \" programming. @@\")\n    fmt.Printf(\"18. CutSuffix: %q %t\\n\", before, found) // \"Hello, World@ Welcome to Go\" true\n}\n</code></pre>"},{"location":"Basic/6.3%20map/","title":"map","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n)\n\n// map in Go is similar to unordered_map in C++ and hash table in other languages\nfunc main() {\n\n    // Declare a map\n    var a map[int]int\n    if a == nil {\n        fmt.Printf(\"a == nil. len = %d \\n\", len(a))\n    }\n    // Init a map\n    a = make(map[int]int)\n    if a != nil {\n        fmt.Printf(\"a != nil. len = %d \\n\", len(a))\n    }\n\n    // Declare and init\n    myMap := map[string]int{}\n    // myMap := map[string]int{\"X\" : 7, \"Y\": 8} // init with literal\n    myMap[\"A\"] = 3\n    myMap[\"B\"] = 4\n    myMap[\"C\"] = 5\n\n    // iterate map\n    fmt.Println(\"First iterate: \")\n    for key := range myMap {\n        fmt.Printf(\"myMap[%s] = %d \\n\", key, myMap[key])\n    }\n\n    fmt.Println(\"Second iterate: \")\n    for key, value := range myMap {\n        fmt.Printf(\"myMap[%s] = %d \\n\", key, value)\n    }\n\n    // Delete value\n    delete(myMap, \"A\")\n    fmt.Println(\"After delete \\\"A\\\": \")\n    for key, value := range myMap {\n        fmt.Printf(\"myMap[%s] = %d \\n\", key, value)\n    }\n\n    // Check exist\n    value, exist := myMap[\"A\"]\n    fmt.Printf(\"Is exist: %t.  myMap[\\\"A\\\"]= %d \\n\", exist, value)\n\n    // map is reference type (similar to slice)\n    // the assignment operator does not perform a deep copy; it just points to myMap.\n    myMap2 := map[string]int{}\n    myMap2 = myMap\n    myMap[\"B\"] = 1 // also make change myMap2[\"B\"]\n    for key := range myMap2 {\n        fmt.Printf(\"myMap2[%s]: %d \\n\", key, myMap2[key])\n    }\n\n    // Nested map\n    nestedMap := map[int]map[string]int{}\n    nestedMap[1] = myMap\n    nestedMap[2] = myMap\n    nestedMap[3] = make(map[string]int)\n\n    nestedMap[2][\"B\"] = -1 // this also changes in nestedMap[1][\"B\"] because nestedMap[1] also points to myMap\n    for key := range nestedMap {\n        fmt.Printf(\"nestedMap[%d]: %v \\n\", key, nestedMap[key])\n    }\n}\n</code></pre>"},{"location":"Basic/7.0%20struct/","title":"struct","text":"<pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n)\n\n// There are no classes, only structs. Structs can have methods.\ntype Person struct {\n    Name   string\n    Age    int8\n    Height float32\n    Job    // member is embedded structs\n\n    // member is nested struct\n    Address struct {\n        Street, City string\n    }\n\n    // member is nested slice struct\n    Phone []struct {\n        Prefix string\n        Number string\n    }\n\n    // member is function\n    CalculateSum func(int, int) int\n}\n\ntype Job struct {\n    Title  string\n    Salary int\n}\n\n// Define methods of Person\nfunc (p *Person) Greeting() {\n    fmt.Println(\"Hi, Im \" + p.Name)\n}\nfunc (p *Person) MakeBirthday() int8 {\n    p.Age++\n    return p.Age\n}\n\nfunc main() {\n\n    // Declare and init\n    var person1 Person\n    person1.Name = \"VietPQ\"\n    person1.Age = 18\n    person1.Height = 1.7\n    person1.Address.Street = \"Huynh Tan Phat\"\n    person1.Address.City = \"HCM\"\n    fmt.Printf(\"person1: %+v \\n\", person1)\n\n    person2 := Person{\n        Name: \"PhungQuocViet\",\n        Age:  20,\n        Job: Job{\n            Title:  \"Software Engineer\",\n            Salary: 10000,\n        },\n\n        Address: struct {\n            Street string\n            City   string\n        }{\n            Street: \"Default_Street\",\n            City:   \"Default_City\",\n        },\n\n        Phone: []struct {\n            Prefix string\n            Number string\n        }{\n            {Prefix: \"+84\", Number: \"3896786543\"},\n            {Prefix: \"+03\", Number: \"6583595284\"},\n        },\n\n        CalculateSum: func(a, b int) int { return a + b },\n    }\n    fmt.Printf(\"person2: %+v \\n\\n\", person2)\n\n    // Call member function\n    sum := person2.CalculateSum(3, 4)\n    fmt.Printf(\"person2 calculate sum: %v \\n\", sum)\n\n    // Call Person's methods\n    person2.Greeting()\n    newAge := person2.MakeBirthday()\n    fmt.Printf(\"My new age is: %d \\n\", newAge)\n\n    // Anonymous structs\n    pair := struct {\n        first  int\n        second int\n    }{\n        first:  12,\n        second: 23,\n    }\n    // or:\n    // pair := struct {\n    //  first  int\n    //  second int\n    // }{12, 23}\n    fmt.Printf(\"%+v \\n\\n\", pair)\n\n    // Tags in structs. Useful for Serialize /Deserialize\n    type Dog struct {\n        Name string `json:\"name of dog\"`\n        Age  int    `json:\"age of dog\"`\n    }\n\n    dog := Dog{\n        Name: \"Lyly\",\n        Age:  2,\n    }\n\n    jsonData, err := json.Marshal(dog) // serialize to JSON\n    if err != nil {\n        fmt.Println(err)\n    }\n    fmt.Printf(\"jsonData: %s\\n\", string(jsonData)) // jsonData: {\"name of dog\":\"Lyly\",\"age of dog\":2}\n\n    var dog2 Dog\n    err = json.Unmarshal(jsonData, &amp;dog2) // deserialize from JSON\n    if err != nil {\n        fmt.Println(err)\n    }\n    fmt.Printf(\"dog2: %+v\\n\", dog2) // dog2: {Name:Lyly Age:2}\n\n}\n</code></pre>"},{"location":"Basic/7.1%20interface/","title":"interface","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// 1. Declare interface\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\n// 2. Implement method of interface Shape\ntype Rectangle struct {\n    Width  float64\n    Height float64\n}\n\nfunc (this Rectangle) Area() float64 {\n    return this.Width * this.Height\n}\n\nfunc (this Rectangle) Perimeter() float64 {\n    return (this.Width + this.Height) * 2\n}\n\ntype Circle struct {\n    x, y   float64\n    Radius float64\n}\n\nfunc (this Circle) Area() float64 {\n    return math.Pi * math.Pow(this.Radius, 2)\n}\n\nfunc (this Circle) Perimeter() float64 {\n    return 2 * math.Pi * this.Radius\n}\n\n// 3. Empty interface. similar to std::any in C++ and `any` in Typescript\ntype Any interface{}\n\nfunc printSomething(arg Any) {\n    fmt.Println(arg)\n}\n\n// 4. Embedded interface\ntype Speaker interface {\n    Speak() string\n}\n\ntype Walker interface {\n    Walk()\n}\n\ntype Human interface {\n    Speaker // similar to implement Speaker\n    Walker  // similar to implement Walker\n    Fuck()\n}\n\ntype Employee struct {\n    ID     string\n    Salary float64\n}\n\nfunc (this Employee) Speak() string {\n    fmt.Println(\"Im \" + this.ID)\n    return \"Im \" + this.ID\n}\n\nfunc (this Employee) Walk() {\n    fmt.Println(this.ID + \" walking\")\n}\n\nfunc (this Employee) Fuck() {\n    fmt.Println(this.ID + \" fucking\")\n}\n\n// 5. Difference in Interface behavior for Pointer Receiver and Value Receiver\ntype Storage interface {\n    Store(data string)\n    Retrieve() string\n}\n\ntype MemoryStorage struct {\n    data string\n}\n\nfunc (m MemoryStorage) Store(data string) {\n    m.data = data\n}\n\nfunc (m MemoryStorage) Retrieve() string {\n    return m.data\n}\n\ntype FileStorage struct {\n    data string\n}\n\nfunc (f *FileStorage) Store(data string) {\n    f.data = data\n}\n\nfunc (f *FileStorage) Retrieve() string {\n    return f.data\n}\n\nfunc main() {\n\n    // interface usage\n    var myShape Shape\n    myShape = Rectangle{Width: 4, Height: 5}\n    fmt.Printf(\"Address of myShape: %p \\n\", &amp;myShape)\n    fmt.Printf(\"Type of myShape: %T \\n\", myShape)\n    fmt.Printf(\"Type of &amp;myShape: %T \\n\", &amp;myShape)\n    fmt.Printf(\"Area of myShape = %f\\n\", myShape.Area())\n    fmt.Printf(\"Perimeter of myShape = %f\\n\\n\", myShape.Perimeter())\n\n    myShape = Circle{Radius: 1}\n    fmt.Printf(\"Address of myShape: %p \\n\", &amp;myShape)\n    fmt.Printf(\"Type of myShape: %T \\n\", myShape)\n    fmt.Printf(\"Type of &amp;myShape: %T \\n\", &amp;myShape)\n    fmt.Printf(\"Area of myShape = %f\\n\", myShape.Area())\n    fmt.Printf(\"Perimeter of myShape = %f\\n\\n\", myShape.Perimeter())\n\n    // test for empty interface\n    printSomething(1997.55)\n    printSomething(\"ABCDEF\")\n    printSomething([]struct { // even with complex struct\n        first  int\n        second string\n        arr    []byte\n    }{\n        {97, \"VietPQ1\", []byte{1, 2, 3}},\n        {98, \"VietPQ2\", []byte{4, 5, 6}},\n        {99, \"VietPQ3\", []byte{7, 8, 9}},\n    })\n\n    // (3) type assertion\n    var myVariable interface{}\n    myVariable = \"Hihi\"\n    // myVariable = 123\n    // myVariable = Rectangle{Width: 2, Height: 3}\n    // myVariable = struct {\n    //  Name string\n    //  Age  int\n    // }{\"Viet\", 18}\n\n    if val, ok := myVariable.(string); ok {\n        // do something\n        fmt.Printf(\"myVariable is string. myVariable = %v \\n\", val)\n    } else if val, ok := myVariable.(int); ok {\n        // do something\n        fmt.Printf(\"myVariable is int. myVariable = %v \\n\", val)\n    } else if val, ok := myVariable.(Rectangle); ok {\n        // do something\n        fmt.Printf(\"myVariable is Rectangle. myVariable = %v \\n\", val)\n    } else {\n        // do something\n        fmt.Printf(\"myVariable is %T. myVariable = %v \\n\", myVariable, myVariable)\n    }\n\n    switch v := myVariable.(type) {\n    case int:\n        fmt.Println(\"Integer:\", v)\n    case string:\n        fmt.Println(\"String:\", v)\n    case Rectangle:\n        fmt.Println(\"Rectangle:\", v)\n    case struct {\n        Name string\n        Age  int\n    }:\n        fmt.Println(\"Person:\", v)\n    default:\n        fmt.Println(\"Unknown type\")\n    }\n\n    sumFunc := func(a, b interface{}) interface{} {\n        switch a.(type) {\n        case int:\n            return a.(int) + b.(int)\n        case float32, float64:\n            return a.(float64) + b.(float64)\n        default:\n            return fmt.Errorf(\"type not support\")\n        }\n    }\n\n    fmt.Printf(\"sumFunc: %d \\n\", sumFunc(12, 13))\n    fmt.Printf(\"sumFunc: %f \\n\", sumFunc(12.1, 13.1))\n\n    // test for (4)\n    var human Human\n    human = Employee{ID: \"VietPQ1007\"} // `Employee` must implement all method of `Human`\n    human.Speak()\n    human.Fuck()\n    human.Walk()\n\n    // test for (5)\n    var storage Storage\n\n    // storage = &amp;MemoryStorage{} // work\n    storage = MemoryStorage{} // work\n    storage.Store(\"this is memory data\")\n    fmt.Println(\"MemoryStorage:\", storage.Retrieve()) // Output will be empty because memory is a value type and changes won't persist\n\n    storage = &amp;FileStorage{} // work\n    // storage = FileStorage{} // NOT WORK ? Why ???\n    storage.Store(\"this is file data\")\n    fmt.Println(\"FileStorage:\", storage.Retrieve()) // Output: File data\n}\n</code></pre>"},{"location":"Basic/8.%20type_conversion/","title":"type conversion","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"unsafe\"\n)\n\nfunc main() {\n\n    // Convert basic type\n    var a int = 65\n    var b float64 = float64(a)\n    fmt.Println(b)\n\n    var c string = string(a)\n    fmt.Println(c)\n\n    a = -1\n    var d uint = uint(a) // similar to C++\n    fmt.Println(d)\n\n    // Similar to C++, Go allow convert large int to small int (possible loss data)\n    a = 999999\n    var y int16 = int16(a)\n    fmt.Println(y)\n\n    // strconv package: convert between string and basic types\n    val, err := strconv.Atoi(\"123\")\n    if err == nil {\n        fmt.Println(val)\n    } else {\n        fmt.Println(err)\n    }\n    str := strconv.Itoa(456)\n    fmt.Println(str)\n\n    val1, err := strconv.ParseBool(\"TRUE\")\n    fmt.Printf(\"Convert string to bool: %v %v \\n\", val1, err)\n\n    val2, err := strconv.ParseFloat(\"99.99\", 32)\n    fmt.Printf(\"Convert string to float: %v %v \\n\", val2, err)\n\n    val3, err := strconv.ParseInt(\"1997\", 10, 32)\n    fmt.Printf(\"Convert string to int: %v %v \\n\", val3, err)\n\n    // string and byte slice/ rune slice\n    str1 := \"ABCDabcd\"\n    byteSlice := []byte(str1)\n    fmt.Printf(\"%v \\n\", byteSlice)\n    runeSlice := []rune(str1)\n    fmt.Printf(\"%v \\n\", runeSlice)\n\n    str2 := string(byteSlice)\n    fmt.Printf(\"%v \\n\", str2)\n    str3 := string(runeSlice)\n    fmt.Printf(\"%v \\n\", str3)\n\n    // It is possible to use `fmt` for string conversions,\n    // but `strconv` is considered best practice.\n    num := 789\n    numStr := fmt.Sprintf(\"%d\", num)\n    fmt.Println(numStr)\n\n    var scannedNum int\n    fmt.Sscanf(\"123\", \"%d\", &amp;scannedNum)\n    fmt.Println(scannedNum)\n\n    //? What happens if you convert between different structs?\n    type Pair struct {\n        first, second int\n        third         float64\n    }\n    type Point struct {\n        // The Point's field must be exactly the same as the Pair's field.\n        // change (field name || field type || field order ||  field amount) =&gt; cannot convert Pair to Point\n        first, second int\n        third         float64\n    }\n    type Coord struct {\n        // same data type and number of fields but difference field name =&gt; cannot convert Pair to Coord\n        x, y  int\n        third float64\n    }\n\n    // convert between difference structs\n    var pair = Pair{1, 2, 3.99}\n    var point Point = Point(pair)\n    fmt.Printf(\"%v \\n\", point)\n    // var coord Coord = Coord(pair) // cause compile err\n    // *Insight gained: Because the Point's field exactly the same as the Pair's field =&gt; should use Type Alias:\n    // `type Point = Pair`\n\n    // convert pointer\n    var f float32 = 5.7788\n    // var ptr2 *int32 = (*int32)(&amp;f) // cause compile err\n    var unsafePtr unsafe.Pointer = unsafe.Pointer(&amp;f) // must use unsafe pointer for convert difference pointer type\n    var ptr2 *int32 = (*int32)(unsafePtr)\n    fmt.Printf(\"%v \\n\", unsafePtr)\n    fmt.Printf(\"%v \\n\", ptr2)\n    fmt.Printf(\"%p \\n\", &amp;f)\n\n    // Custom type conversions. \n    type MyInt int\n    var myInt MyInt = 5\n    var regularInt int = int(myInt)\n    fmt.Println(regularInt)\n}\n</code></pre>"},{"location":"Basic/9.%20comparison_and_copy/","title":"comparision and copy","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"reflect\"\n)\n\ntype Shape interface {\n    Area() float64\n    Perimeter() float64\n}\n\ntype Rectangle struct {\n    Width  float64\n    Height float64\n}\n\nfunc (this Rectangle) Area() float64 {\n    return this.Width * this.Height\n}\n\nfunc (this Rectangle) Perimeter() float64 {\n    return (this.Width + this.Height) * 2\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (this Circle) Area() float64 {\n    return math.Pi * math.Pow(this.Radius, 2)\n}\n\nfunc (this Circle) Perimeter() float64 {\n    return 2 * math.Pi * this.Radius\n}\n\nfunc main() {\n    // Part A. Comparison in Go\n    // 1. Difference type: cause compile error\n    // Go can only compare values of the same type or types that are comparable\n    var a int = 12\n    var b int32 = 13\n    // fmt.Printf(\"%t\", (a == b)) // even both a and b is integer number\n    fmt.Printf(\"a == b: %t \\n\", (a == int(b))) // need type convert beforce compare\n\n    // 2. Same type\n    // basic type: bool, numer, string,... compare its actual value\n    var str1 string = \"Hello\"\n    var str2 string = \"Hello\"\n    fmt.Printf(\"str1 == str2: %t \\n\", (str1 == str2))\n\n    // array: compares each element recursively\n    arr1 := [3]int{7, 8, 9}\n    arr2 := [3]int{7, 8, 9}\n    fmt.Printf(\"arr1 == arr2: %t \\n\", (arr1 == arr2))\n\n    // slice: not directly comparable (slice can only be compared to nil)\n    slice1 := []int{7, 8, 9}\n    slice2 := []int{7, 8, 9}\n    // fmt.Printf(\"slice1 == slice2: %t \\n\", (slice1 == slice2)) // cause compile error\n    fmt.Printf(\"slice1 == slice2: %t \\n\", (reflect.DeepEqual(slice1, slice2)))\n    fmt.Printf(\"Slice1 == nil: %t \\n\", (slice1 == nil))\n    fmt.Printf(\"Slice2 == nil: %t \\n\", (slice2 == nil))\n\n    // map: not directly comparable (map can only be compared to nil)\n    map1 := map[int]string{1: \"AA\", 2: \"BB\"}\n    map2 := map[int]string{1: \"AA\", 2: \"BB\"}\n    // fmt.Printf(\"Map: %t \\n\", (map1 == map2)) // cause compile error\n    fmt.Printf(\"map1 == map2: %t \\n\", reflect.DeepEqual(map1, map2))\n    fmt.Printf(\"map1 == nil: %t \\n\", (map1 == nil))\n    fmt.Printf(\"map2 == nil: %t \\n\", (map2 == nil))\n\n    // pointer: compares memory address that they point to\n    x := 123\n    y := 123\n    ptr1 := &amp;x\n    ptr2 := &amp;x\n    fmt.Printf(\"ptr1 == ptr2 %t \\n\", (ptr1 == ptr2))\n    ptr2 = &amp;y\n    fmt.Printf(\"ptr1 == ptr2: %t \\n\", (ptr1 == ptr2))\n\n    // struct: compares each fields recursively\n    type Job struct {\n        Title  string\n        Salary int\n    }\n    type Person struct {\n        Name string\n        Age  int8\n        Job  *Job\n\n        Address struct {\n            Street, City string\n        }\n\n        // array is comparable\n        Phone [2]struct {\n            Prefix string\n            Number string\n        }\n\n        // uncomment =&gt; slice in struct will make cannot comparable by `==` (except using reflect.DeepEqual())\n        // Phone []struct {\n        //  Prefix string\n        //  Number string\n        // }\n\n        // uncomment =&gt; function cannot comparable. Even using reflect.DeepEqual() =&gt; only true when both CalculateSum is nil\n        // CalculateSum func(int, int) int\n    }\n\n    person1 := Person{\n        Name: \"Alice\",\n        Age:  25,\n        Job: &amp;Job{\n            Title:  \"Software Engineer\",\n            Salary: 80000,\n        },\n        Address: struct {\n            Street, City string\n        }{\n            Street: \"123 Main St\",\n            City:   \"Metropolis\",\n        },\n        Phone: [2]struct {\n            Prefix string\n            Number string\n        }{\n            {Prefix: \"+1\", Number: \"1234567890\"},\n            {Prefix: \"+1\", Number: \"0987654321\"},\n        },\n    }\n\n    person2 := Person{\n        Name: \"Alice\",\n        Age:  25,\n        Job: &amp;Job{\n            Title:  \"Software Engineer\",\n            Salary: 80000,\n        },\n        Address: struct {\n            Street, City string\n        }{\n            Street: \"123 Main St\",\n            City:   \"Metropolis\",\n        },\n        Phone: [2]struct {\n            Prefix string\n            Number string\n        }{\n            {Prefix: \"+1\", Number: \"1234567890\"},\n            {Prefix: \"+1\", Number: \"0987654321\"},\n        },\n    }\n\n    fmt.Printf(\"person1 == person2: %t \\n\", (person1 == person2))                                // this false because field Job is pointer =&gt; compare memory address\n    fmt.Printf(\"reflect.DeepEqual(person1, person2: %t \\n\", reflect.DeepEqual(person1, person2)) // true\n    person2.Job = person1.Job\n    fmt.Printf(\"person1 == person2: %t \\n\", (person1 == person2))\n\n    // interface: first compare type, then compare value. (both pointer receiver and value receiver)\n    var shape1, shape2, shape3, shape4 Shape\n    shape1 = Rectangle{Width: 4, Height: 3}\n    shape2 = Rectangle{Width: 4, Height: 3}\n    shape3 = Rectangle{Width: 4, Height: 4}\n    shape4 = Circle{Radius: 1}\n    fmt.Printf(\"shape1 == shape2: %t \\n\", (shape1 == shape2))\n    fmt.Printf(\"shape2 == shape3: %t \\n\", (shape2 == shape3))\n    fmt.Printf(\"shape3 == shape4: %t \\n\", (shape3 == shape4))\n\n    // -----------------------------------------------------------------------------------------\n    // Part B. Copying in Go\n    // 1. Shallow copy: slice, map, pointer\n    // 2. Deep copy: basic type (bool, int, string, ...), struct, array\n\n\n}\n</code></pre>"}]}